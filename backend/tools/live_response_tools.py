# tools/live_response_tools.py
import subprocess
from google.adk.tools import ToolContext
import os
import socket
import re

def generate_streaming_script(tool_context: ToolContext) -> dict:
    """
    Produces a small bash script based on session state values or file paths from user content.
    Expects server_ip and server_port in tool_context.state or extracts target files from user content.
    """
    # Get user content from the conversation context
    user_content = ""
    try:
        # Try to get the user's most recent message content
        if hasattr(tool_context, 'messages') and tool_context.messages:
            user_content = str(tool_context.messages[-1].get('content', ''))
        elif hasattr(tool_context, 'request') and tool_context.request:
            user_content = str(tool_context.request)
        else:
            user_content = str(tool_context)
    except:
        user_content = ""
    
    print(f"DEBUG: Live response tool received content: {user_content[:200]}...")
    
    # Extract file paths from user content
    file_patterns = [
        r'/tmp/[^\s]+',  # Files in /tmp directory
        r'/home/[^\s]+', # Files in home directories
        r'/var/[^\s]+',  # System files in /var
        r'[^\s]*\.mem',  # Memory dump files
        r'[^\s]*\.lime', # LIME memory dumps
        r'[^\s]*\.raw',  # Raw disk/memory images
        r'[^\s]*\.dd',   # Disk dump files
    ]
    
    extracted_paths = []
    for pattern in file_patterns:
        matches = re.findall(pattern, user_content)
        extracted_paths.extend(matches)
    
    state = tool_context.state
    server_ip = state.get("server_ip", "127.0.0.1")
    server_port = state.get("server_port", 9999)
    analysis_type = state.get("analysis_type", "live_memory")
    
    if extracted_paths:
        print(f"DEBUG: Extracted file paths from user content: {extracted_paths}")
        # Use the first extracted path as target
        target_file = extracted_paths[0]
        
        # Generate script to stream the specified file
        script_content = f"""#!/bin/bash
# Auto-generated by Aegis Forensics LiveResponseAgent
SERVER_IP="{server_ip}"
SERVER_PORT="{server_port}"
TARGET_FILE="{target_file}"
HOSTNAME=$(hostname)

echo "[1] Streaming {target_file} to ${{SERVER_IP}}:${{SERVER_PORT}}..."

if [ ! -f "${{TARGET_FILE}}" ]; then
    echo "Error: Target file ${{TARGET_FILE}} does not exist"
    exit 1
fi

nc ${{SERVER_IP}} ${{SERVER_PORT}} < "${{TARGET_FILE}}"

if [ $? -eq 0 ]; then
    echo "Successfully streamed ${{TARGET_FILE}}"
else
    echo "Failed to stream ${{TARGET_FILE}}"
    exit 1
fi

echo "Done."
"""
        return {
            "status": "success", 
            "script_filename": f"stream_{os.path.basename(target_file)}.sh", 
            "script_content": script_content,
            "target_file": target_file
        }
    
    # Fallback to original behavior if no file paths found
    print("DEBUG: No file paths found, generating default live memory capture script")
    
    if analysis_type == "live_memory":
        script_content = f"""#!/bin/bash
# Auto-generated by Aegis Forensics LiveResponseAgent
SERVER_IP="{server_ip}"
SERVER_PORT="{server_port}"
HOSTNAME=$(hostname)
OUT="/tmp/${{HOSTNAME}}_memory.lime"
echo "[1] Capturing memory with avml..."
avml "${{OUT}}"
if [ $? -ne 0 ]; then
  echo "avml failed."
  exit 1
fi
echo "[2] Streaming to ${{SERVER_IP}}:${{SERVER_PORT}}..."
nc ${{SERVER_IP}} ${{SERVER_PORT}} < "${{OUT}}"
rm -f "${{OUT}}"
echo "Done."
"""
        return {"status": "success", "script_filename": "live_memory_streamer.sh", "script_content": script_content}
    else:
        return {"status": "error", "message": f"Unsupported analysis_type: {analysis_type}"}
